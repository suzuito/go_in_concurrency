
## RaceConditions

コードの実行順序が保証されていないことによるバグ。

### 「保証されている」ということがどれだけ重要か？

自分のPCでは、サンプルコードを1000回繰り返した場合でも、`the value is 0`が表示される。
だからこのコードは**現実的には0という結果になるから良いじゃん！というのはアカン。**

サンプルコードの重大な問題点は、結果が0になること（コードの実行順序）が「保証されていない」ということ。コンピュータサイエンスにおいて、「ある結果になることが保証されている」という場合、「100%その結果になる」ということを表している。だから、「保証されている」と「保証されていない」という用語の間には雲泥の差がある。

```bash
for i in `seq 1 1000`; do go run 1/race_conditions/main.go; done
```

サンプルコードを1000000回繰り返したら、`the value is 0`とならない場合が１回だけ起こるかも知れない。**保証されていないけど大体の場合は大丈夫**という心の隙が見つけにくいバグを生む。なぜなら、24時間休みなく稼働するソフトウェアにおいて、コードの実行回数はすぐに1000000回に到達してしまうからだ。

（例）何かの待ち処理をするために「スリープを入れる」という方法を良くやる。

### RaceConditionsの見つけにくいバグの例

コードの実行順序が保証されていないプログラムがあるとする。
このプログラムはマシンの負荷が小さいときは正しく動作する。
しかしマシンの負荷が大きくなると、プログラム中の特定のコードに時間がかかるようになり、コードの実行順序が変わる、とか。

「高負荷」は、WebScaleが前提されているプログラムでは容易に発生する。
高負荷の影響により良く発生するのは

- ディスクIOが大きくなり、ファイルの読み書きに時間がかかるようになる
- CPU負荷が高まり、実行が遅くなる
- ネットワークの負荷が大きくなり、WebAPIからのレスポンスが遅くなる

### 昔、分散環境におけるRaceConditionsの解消のために、Zookeeperを使った。

7年ほど前に、ZookeeperというOSSを使用した。
これは、分散環境におけるRaceConditionsを解消するためのものだ。
これはHadoopでも使用されている。

Zookeeperは、分散環境のRaceConditionsを回避するために使用するファイルシステム。
分散環境においてRaceConditionsを発生させないためには、一貫性が完備されたデータベース（RDBのような）を使用することで回避する。しかしながら、RDBはスケールできない。
Zookeeperは、ある程度はスケールすることができる。

Zookeeperの欠点は、ACIDにおけるD、つまり「永続性」がないということ。

今なら、分散環境におけるRaceConditionsを回避するためのOSSの筆頭は、ZookeeperではなくKubenetesとかになるのかな？

## Atomicity

### RDBの原子性とは若干異なるので注意

http://e-words.jp/w/%E5%8E%9F%E5%AD%90%E6%80%A7.html#:~:text=%E3%81%AE%E3%82%A2%E3%83%88%E3%83%9F%E3%83%83%E3%82%AF%E6%80%A7-,%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%8E%9F%E5%AD%90%E6%80%A7,%E3%81%93%E3%81%A8%E3%82%92%E5%8E%9F%E5%AD%90%E6%80%A7%E3%81%A8%E3%81%84%E3%81%86%E3%80%82

### Context

アトミックにする一連のオペレーション。
常にContextを意識することが必要となる。

## Memory Access Synchronization

javaのsyncにあたるのが、goのmutext.Lock。

## Deadlocks

